---
layout: post
title: magicblog开发日记(4)-文章分页，RSS输出，sitemap
category: essay
---

<h1>1.文章分页</h1>
Django的Pagination就是用来当条目过多时分页显示的，可以方便使用
由于我们的首页post列表，tag和categor列表都是用了我们自定义的blog_generic_view，我们只要再改其中加入一个是否分页的变量即可实现：

[code]
def blog_generic_view(request, redirect_to, paginate = True, **view_args):
    view_args['queryset'] = view_args.get('queryset', Post.objects.all())
    view_args['template_object_name'] = 'post'

    if paginate:
        view_args['paginate_by'] = 5

    return redirect_to(request, **view_args)
[/code]

上面的代码中，如果paginate为真时，以每页5个的规则显示(默认为真)
只有single post的时候不需要分页，所以在single post对应的url中加入'paginated': False参数：

[code]
   url(r'^post/(?P&lt;slug&gt;[a-z-]+)/$', blog_generic_view,
        {'redirect_to': list_detail.object_detail, 'slug_field': 'slug', 'paginated': False,}, name=&quot;single_post&quot;),
[/code]

再在blog_list.html中加入对应pagination的tempalte即可：

[code]
	{% endif %}
	{% if post_list.count %}
		{% for post in post_list %}
			{% include &quot;blog/post.html&quot; %}
		{% endfor %}
	{% else %}
		&lt;p&gt;There are no items to display...&lt;/p&gt;
	{% endif %}
[/code]
<h1>2.RSS输出</h1>
使用Django的<a href="http://docs.djangoproject.com/en/dev/ref/contrib/syndication/">The syndication feed framework</a>可以方便的实现RSS功能。
首先在urlpattern中添加下面这条：
(r'^feeds/(?P.*)/$', 'django.contrib.syndication.views.feed', {'feed_dict': feeds}),
我们要定义一个继承自Feed类的类，并在其中定义title, link, description和items，如下：

[code]
from django.contrib.syndication.feeds import Feed
from mysite.blog.models import Post

class BlogLatestEntries(Feed):
    title = &quot;The super Blog&quot;
    link = &quot;/&quot;
    description = &quot;The latest stuff in the blog.&quot;

    def items(self):
        return Post.objects.all()[:5]
[/code]

以最近的5篇文章作为RSS输出。在urlpattern中，'feed_dict': feeds还需要我们定义feeds，它的定义要放在urls.py的上面：

[code]
from mysite.blog.feeds import BlogLatestEntries

feeds = {
    'latest': BlogLatestEntries,
}
[/code]

至于feed对应的template，根据文档知道，Django会自动用feeds/_title.html和feeds/_description.html作为template，我们分别创建这两个文件，内容都非常简单，分别为：{{ obj.title }}和{{ obj.body }}。然而Django现在还无法知道每个item的url，这可以通过给Post类添加一个get_absolute_url方法实现：

[code]
    @models.permalink
    def get_absolute_url(self):
        return ('single_post', [self.slug])
[/code]

这样的话，访问www.example.com/feeds/latest既可以得到最新的RSS feed
<h1>3.sitemap</h1>
sitemap的实现与rss非常相似，Django同样帮助我们省去了很多工作，详细文档可以参见<a href="http://docs.djangoproject.com/en/dev/ref/contrib/sitemaps/#overview">The sitemap framework</a>。
同样是先要在urls.py中添加一行：
url(r'^sitemap\.xml$', 'django.contrib.sitemaps.views.sitemap', {'sitemaps' : sitemaps}),
然后就要考虑Sitemap类了，可以继承Sitemao类实现自己的类，也可以利用两个特殊的Sitemap类的子类：

[code]
info_dict = {
    'queryset': Post.objects.all(),
    'date_field' : 'pub_date',
}

sitemaps = {
    'flatpages' : FlatPageSitemap,
    'blog' : GenericSitemap(info_dict, priority=0.6, changefreq = &quot;monthly&quot;),
}
[/code]

上面的代码用到了Django的<a href="http://docs.djangoproject.com/en/dev/ref/contrib/flatpages/#module-django.contrib.flatpages">flatpages</a>，通过使用flatpage，我们可以轻松创建如about页面这样的不太变化的页面，很方便。
上面的代码分别用了Sitemap的两个特殊子类FlatPageSitemap和GenericSitemap，后者对应于generic view，很容易理解。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

现在的magicblog已经完全可以投入使用了，目前最棘手的问题是“导入导出”，并且要和wordpress的格式兼容，关于这个问题，我现在还没什么思路。

明天就是大年三十了，过完年再说吧。